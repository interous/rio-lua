'prelude.rio import

"  " set-backend-indent

'check-rational {
  !lit 0 #idx !i
  #false !found-dot
  { lit i at '- quote->char = } { i inc :i } if

  { } { i lit len < } { i inc :i }
  { lit i at !cur
    { cur '. quote->char = found-dot and }
    { "Failed to parse " lit " as rational (found two dots)" ++ ++
      compile-error
    }
    { cur '. quote->char = } { #true :found-dot }
    { cur '0 quote->char < cur '9 quote->char > or }
    { "Failed to parse " lit " as rational: " cur char->quote " not a digit"
      ++ ++ ++ ++ compile-error
    } if
  } for
} macro

'check-integral {
  !lit 0 #idx !i
  { lit i at '- quote->char = } { i inc :i } if

  { } { i lit len < } { i inc :i }
  { lit i at !cur
    { cur '0 quote->char < cur '9 quote->char > or }
    { "Failed to parse " lit " as integral: " cur char->quote " not a digit"
      ++ ++ ++ ++ compile-error
    } if
  } for
} macro

'make-numeric-type {
  !repr '#B require-type !size !kind !type
  type add-type
  type { dup 'check- ^kind ++ eval 'quote-> ^type ++ eval } inject macro

  type '->quote ++ { '__quote unsafe-set-type } macro
  '_ type '_to-quote ++ ++ { '__quote unsafe-set-type } macro
  'quote-> type ++ { ^type unsafe-set-type } inject macro
  type '->repr ___quote___quote_++ { ^repr } inject macro
  '_ type '_repr-of ___quote___quote_++ ___quote___quote_++ {
    drop ^repr
  } inject macro
  type '->size ++ { ^size } inject macro
  '_ type '_size-of ++ ++ { drop ^size } inject macro

  '_ type '_ type '_ ++ ++ ++ ++ !preface

  '_ type '_declare ++ ++ {
    ^repr " " ++ swap '; ++ ++ backend-declare
  } inject macro
  '_ type '_commit ++ ++ {
    !val !name
    name " = " val to-quote '; ++ ++ ++ backend-code
  } macro

  preface '+ ++ {
    !b !a
    '( a to-quote " + " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '* ++ {
    !b !a
    '( a to-quote " * " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '< ++ {
    !b !a
    '( a to-quote " < " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '= ++ {
    !b !a
    '( a to-quote " == " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '/= ++ {
    !b !a
    '( a to-quote " != " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro
} macro

'make-decision-type {
  !type
  type add-type
  type decision-type
  type {
    !val
    { val '0 /= val '1 /= and }
    { "Invalid literal to decision constructor; must be 0 or 1" compile-error }
    if
    val 'quote-> ^type ++ eval
  } inject macro
  type '->quote ++ {
    '__quote unsafe-set-type
  } macro
  '_ type '_to-quote ++ ++ {
    '__quote unsafe-set-type
  } macro
  'quote-> type ++ { ^type unsafe-set-type } inject macro

  [ We're using int as the underlying decision type ]
  type '->size ++ { 4 #B } macro
  '_ type '_size-of ++ ++ { drop 4 #B } macro

  '_ type '_ type '_ ++ ++ ++ ++ !preface

  '_ type '_declare ++ ++ {
    "int " swap '; ++ ++ backend-declare
  } macro
  '_ type '_commit ++ ++ {
    !val !name
    name " = " val to-quote '; ++ ++ ++ backend-code
  } macro

  preface 'and ++ {
    !b !a
    '( a to-quote " && " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface 'or ++ {
    !b !a
    '( a to-quote " || " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface 'not ++ {
    !a
    '!( swap to-quote ') ++ ++
    a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '= ++ {
    !b !a
    '( a to-quote " == " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '/= ++ {
    !b !a
    '( a to-quote " != " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro
} macro

'int4 'integral 4 #B 'int make-numeric-type
'pointer 'integral pointer-size 'size_t make-numeric-type
'ratio4 'rational 4 #B 'float make-numeric-type
'bool make-decision-type
'B 'pointer unit
'idx 'pointer unit
'B 'bool derive-numeric
'idx 'bool derive-numeric
'B 'idx 'bool 'pointer derive-binary-ratios
'B derive-realization
'idx derive-realization
'B 'idx derive-binary-realizations

'list-type {
  !inner !outer
  outer add-type
  inner '->repr ++ eval !inner-repr
  inner '->size ++ eval #B->B !inner-size
  2 #idx pointer-size * #B*#idx->B*idx !header-size

  [2 #B pointer-size * inner-size / !header-size]

  outer {
    16 idx '*sz default
    *sz ^inner-size * ^header-size + !actual-size
    get-anonymous-name !name
    ^inner-repr "* " name '; ++ ++ ++ backend-declare
    name " = malloc(" actual-size to-quote ");" ++ ++ ++ backend-code
    "#include <stdlib.h>" backend-include
    '((size_t*) name ")[0] = 0;" ++ ++ backend-code
    '((size_t*) name ")[1] = " *sz to-quote '; ++ ++ ++ ++ backend-code
    name ^outer unsafe-set-type
  } inject macro

  '_ outer '_len ++ ++ {
    to-quote !name
    '((size_t*) name ")[0]" ++ ++ quote->idx
  } macro

  '_ outer '_capacity ++ ++ {
    to-quote !name
    '((size_t*) name ")[1]" ++ ++ quote->idx
  } macro

  outer '->repr ++ { ^inner-repr '* ++ } inject macro
  outer '->quote ++ { '__quote unsafe-set-type } macro
  '_ outer '_to-quote ++ ++ { '__quote unsafe-set-type } macro
  'quote-> outer ++ { ^outer unsafe-set-type } inject macro
} macro

'backend-finalize {
  !body !decls
  "int main(int __argv, char** __argc) {\n" decls body "  return 1;\n}\n" ++ ++ ++
} macro

'backend-if {
  !false !true !condition
  "if(" condition to-quote ") {" ++ ++ backend-code
  true backend-raw-code
  "} else {" backend-code
  false backend-raw-code
  "}" backend-code
} macro

'backend-while {
  !body !condition !head
  "while(1) {" backend-code
  head backend-raw-code
  "if(!(" condition to-quote ")) break;" ++ ++ backend-code
  body backend-raw-code
  "}" backend-code
} macro
