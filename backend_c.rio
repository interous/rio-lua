'prelude.rio import

"  " set-backend-indent

[ Header wrappers ]
'C-include { 1 #level backend-header } macro
'C-type { 2 #level backend-header } macro

'size-of 1 #idx poly

'backend-include {
  !name
  { '__ name ++ defined? not }
  { '__ name ++ reserve-name
    name C-include
  } if2
} macro

'check-rational {
  !lit 0 #idx !i
  #false !found-dot
  { lit i at '- quote->char = } { 'i #inc } if

  { } { i lit len < } { 'i #inc }
  { lit i at !cur
    { cur '. quote->char = found-dot and }
    { "Failed to parse " lit " as rational (found two dots)" ++ ++
      compile-error
    }
    { cur '. quote->char = } { #true :found-dot }
    { cur '0 quote->char < cur '9 quote->char > or }
    { "Failed to parse " lit " as rational: " cur char->quote " not a digit"
      ++ ++ ++ ++ compile-error
    } if
  } for
} macro

'check-integral {
  !lit 0 #idx !i
  { lit i at '- quote->char = } { 'i #inc } if

  { } { i lit len < } { 'i #inc }
  { lit i at !cur
    { cur '0 quote->char < cur '9 quote->char > or }
    { "Failed to parse " lit " as integral: " cur char->quote " not a digit"
      ++ ++ ++ ++ compile-error
    } if
  } for
} macro

'make-numeric-type {
  !repr '#B require-type !size !kind !type
  type add-type
  type { dup 'check- ^kind ++ eval 'quote-> ^type ++ eval } inject macro

  type '->quote ++ { '__quote unsafe-set-type } macro
  '_ type '_to-quote ++ ++ { '__quote unsafe-set-type } macro
  'quote-> type ++ { ^type unsafe-set-type } inject macro
  type '->repr ___quote___quote_++ { ^repr } inject macro
  '_ type '_repr-of ___quote___quote_++ ___quote___quote_++ {
    drop ^repr
  } inject macro
  type '->size ++ { ^size } inject macro
  '_ type '_size-of ++ ++ { drop ^size } inject macro

  '_ type '_ type '_ ++ ++ ++ ++ !preface

  '_ type '_declare ++ ++ {
    ^repr " " ++ swap '; ++ ++ backend-declare
  } inject macro
  '_ type '_commit ++ ++ {
    !val !name
    name " = " val to-quote '; ++ ++ ++ backend-code
  } macro

  preface '+ ++ {
    !b !a
    '( a to-quote " + " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '* ++ {
    !b !a
    '( a to-quote " * " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '< ++ {
    !b !a
    '( a to-quote " < " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '= ++ {
    !b !a
    '( a to-quote " == " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '/= ++ {
    !b !a
    '( a to-quote " != " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro
} macro

'make-decision-type {
  !type
  type add-type
  type decision-type
  type {
    !val
    { val '0 /= val '1 /= and }
    { "Invalid literal to decision constructor; must be 0 or 1" compile-error }
    if
    val 'quote-> ^type ++ eval
  } inject macro
  type '->quote ++ {
    '__quote unsafe-set-type
  } macro
  '_ type '_to-quote ++ ++ {
    '__quote unsafe-set-type
  } macro
  'quote-> type ++ { ^type unsafe-set-type } inject macro

  [ We're using int as the underlying decision type ]
  type '->size ++ { 4 #B } macro
  '_ type '_size-of ++ ++ { drop 4 #B } macro

  '_ type '_ type '_ ++ ++ ++ ++ !preface

  '_ type '_declare ++ ++ {
    "int " swap '; ++ ++ backend-declare
  } macro
  '_ type '_commit ++ ++ {
    !val !name
    name " = " val to-quote '; ++ ++ ++ backend-code
  } macro

  preface 'and ++ {
    !b !a
    '( a to-quote " && " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface 'or ++ {
    !b !a
    '( a to-quote " || " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface 'not ++ {
    !a
    '!( swap to-quote ') ++ ++
    a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '= ++ {
    !b !a
    '( a to-quote " == " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro

  preface '/= ++ {
    !b !a
    '( a to-quote " != " b to-quote ') ++ ++ ++ ++
    b merge-aliases a merge-aliases
    'quote-> ^type ++ eval
  } inject macro
} macro

'int4 'integral 4 #B 'int make-numeric-type
'pointer 'integral pointer-size 'size_t make-numeric-type
'ratio4 'rational 4 #B 'float make-numeric-type
'bool make-decision-type
'B 'pointer unit
'idx 'pointer unit
'B 'bool derive-numeric
'idx 'bool derive-numeric
'B 'idx 'bool 'pointer derive-binary-ratios
'B derive-realization
'idx derive-realization
'B 'idx derive-binary-realizations

'inc { dup eval 1 idx + swap rebind } inline
'dec { dup eval 1 idx - swap rebind } inline

[ The following DU-support algorithms are all linear or quadratic, when they
  could be logarithmic or n*log(n), because the expectation is for DUs to
  enumerate a small number of types. Given this, the actual performance should
  be better, since we don't need to do lots of macro recursion.
]

'find-quote-in-block {
  !quote !block
  { -1 #idx !res 0 #idx !i } { i block len < res 0 #idx < and } { 'i #inc }
  { { block i type-in-block '__quote = }
    { { block i at quote = }
      { i :res } if2
    } if2
  } for
  res
} macro

'require-all-unique-quotes {
  !block
  { 0 #idx !i } { i block len < } { 'i #inc }
  { { block i type-in-block '__quote /= }
    { '__quote block i type-in-block type-mismatch } if2
  } for

  { 0 #idx :i } { i block len < } { 'i #inc }
  { { i 1 #idx + !j } { j block len < } { 'j #inc }
    { { block i at block j at = }
      { "block must contain all unique entries, found duplication of "
        block i at ++ compile-error
      } if2
    } for
  } for
  block
} macro

'du {
  require-top-level
  require-all-unique-quotes !types !type

  { 0 #idx !i } { i types len < } { 'i #inc }
  { { types i at is-type? not }
    { types i at " is not a type" ++ compile-error
    } if2
  } for

  { '__du defined? not }
  { '__du reserve-name
    "struct __du {" C-type
    "  size_t type_id;" C-type
    "  void* blob;" C-type
    "};" C-type
  } if2

  type {
    !datum
    ^types datum type-of find-quote-in-block !pos
    { pos 0 #idx < }
    { datum type-of " is not a member of " ^type ++ ++ compile-error } if2

    '__du get-anonymous-name !name
    "#include <stdlib.h>" backend-include
    "struct __du* " name '; ++ ++ backend-declare
    name " = malloc(sizeof(struct __du));" ++ backend-code
    name "->type_id = " pos to-quote '; ++ ++ ++ backend-code
    fi
    { datum type-of 'empty = }
    { "// a DU is being \"assigned\" an empty type here" backend-code }
    { datum size-of pointer-size /= }
    { name "->blob = (void*)(size_t)" datum to-quote '; ++ ++ ++ backend-code }
    { name "->blob = (void*)" datum to-quote '; ++ ++ ++ backend-code }
    if
    name ^type unsafe-set-type
  } inject macro

  '_ type '_match ++ ++ {
    !union !depth
    {}
    { 0 #idx !i } { i depth < } { 'i #inc } { swap block-push } for
    !data
    fi
    { ^types len 2 #idx * depth = }
    { fi
      { 0 #idx :i } { i data len < } { i 2 #idx + :i }
      { data i at !cur-type
        data i 1 #idx + at !cur-block
        ^types cur-type find-quote-in-block !type-id
        { type-id 0 #idx < }
        { cur-type " is not a member of " ^type ++ ++ compile-error } if2

        { i data len 2 #idx - < }
        { {} type-id #idx->idx block-push
          { union to-quote '->type_id ++ quote->idx = } ++
        } if2

        { cur-type 'empty = }
        { cur-block }
        { {} cur-type block-push
          { !cur-type '(( cur-type '->repr ++ eval
            { cur-type '->size ++ eval pointer-size /= }
            { ')(size_t ++ } if2
            ') union to-quote '->blob) ++ ++ ++ ++
            cur-type unsafe-set-type
          } cur-block ++ ++
        } if3
      } for
      if
    }
    { depth ^types len 2 #idx * < }
    { { depth 2 #idx % 0 #idx = }
      { "match must either cover all cases, or have an odd number of clauses"
        compile-error
      } if2
      fi
      { 0 #idx :i } { i data len 1 #idx - < } { i 2 #idx + :i }
      { data i at !cur-type
        data i 1 #idx + at !cur-block
        ^types cur-type find-quote-in-block !type-id
        { type-id 0 #idx < }
        { cur-type " is not a member of " ^type ++ ++ compile-error } if2

        {} type-id #idx->idx block-push
        { union to-quote '->type_id ++ quote->idx = } ++
        { cur-type 'empty = }
        { cur-block }
        { {} cur-type block-push
          { !cur-type '(( cur-type '->repr ++ eval
            { cur-type '->size ++ eval pointer-size /= }
            { ')(size_t ++ } if2
            ') union to-quote '->blob) ++ ++ ++ ++
            cur-type unsafe-set-type
          } cur-block ++ ++
        } if3
      } for
      { union } data data len 1 #idx - at ++
      if
    }
    { "attempting to match more types than the DU enumerates" compile-error }
    if
  } inject macro

  '_ type '_to-quote ++ ++ { '__quote unsafe-set-type } inject macro
} macro

'match {
  {} !data
  #false !done
  { done not }
  { !atom
    { atom type-of '__quote = atom type-of '__block = or }
    { data atom block-push :data }
    { { 0 #idx !i } { i data len < } { 'i #inc } { data i at } for
      data len atom '_ atom type-of '_match ++ ++ eval
      #true :done
    } if3
  } while
} macro

'maybe {
  !type
  type '? ++ { ^type 'empty } inject du

  '_ type '_just-default ++ ++ {
    {} swap block-push 'empty swap
    ^type {}
    match
  } inject macro
} macro

'just-default 1 #idx poly

'list {
  !inner !outer
  outer add-type
  inner '->repr ++ eval !inner-repr
  inner '->size ++ eval #B->B !inner-size
  2 #idx pointer-size * #B*#idx->B*idx !header-size

  [2 #B pointer-size * inner-size / !header-size]

  outer {
    16 idx '*sz default
    *sz ^inner-size * ^header-size + !actual-size
    get-anonymous-name !name
    ^inner-repr "* " name '; ++ ++ ++ backend-declare
    name " = malloc(" actual-size to-quote ");" ++ ++ ++ backend-code
    "#include <stdlib.h>" backend-include
    '((size_t*) name ")[0] = 0;" ++ ++ backend-code
    '((size_t*) name ")[1] = " *sz to-quote '; ++ ++ ++ ++ backend-code
    name ^outer unsafe-set-type
  } inject macro

  '_ outer '_len ++ ++ {
    to-quote !name
    '((size_t*) name ")[0]" ++ ++ quote->idx
  } macro

  '_ outer '_capacity ++ ++ {
    to-quote !name
    '((size_t*) name ")[1]" ++ ++ quote->idx
  } macro

  outer '->repr ++ { ^inner-repr '* ++ } inject macro
  outer '->quote ++ { '__quote unsafe-set-type } macro
  '_ outer '_to-quote ++ ++ { '__quote unsafe-set-type } macro
  'quote-> outer ++ { ^outer unsafe-set-type } inject macro
} macro

'backend-finalize {
  !body !decls
  "int main(int __argv, char** __argc) {\n" decls body "  return 1;\n}\n" ++ ++ ++
} macro

'backend-if {
  !false !true !condition
  "if(" condition to-quote ") {" ++ ++ backend-code
  true backend-raw-code
  "} else {" backend-code
  false backend-raw-code
  "}" backend-code
} macro

'backend-while {
  !body !condition !head
  "while(1) {" backend-code
  head backend-raw-code
  "if(!(" condition to-quote ")) break;" ++ ++ backend-code
  body backend-raw-code
  "}" backend-code
} macro
