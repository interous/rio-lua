'! { bind } prefix
'@ { commit } prefix
'~ { delete } prefix

'rebind {
  dup delete bind
} inline

'recommit {
  dup delete commit
} inline

': { rebind } prefix
'; { recommit } prefix

'unit {
  !repr !type
  type add-type
  type {}
    repr symbol block-push
    type block-push
    'unsafe-set-type symbol block-push
  macro
  type '->repr ___quote___quote_++ {}
    repr block-push
  macro
  '_ type '_repr-of ___quote___quote_++ ___quote___quote_++ { drop }
    repr block-push
  macro
  '_ repr '_commit ___quote___quote_++ ___quote___quote_++ !repr-commit
  { repr-commit defined? }
  { '_ type '_commit ___quote___quote_++ ___quote___quote_++ {}
      repr-commit symbol block-push
    macro
    '_ type '_declare ___quote___quote_++ ___quote___quote_++ {}
      '_ repr '_declare ___quote___quote_++ ___quote___quote_++
        symbol block-push
    macro
    type '->quote ___quote___quote_++ {
      '__quote unsafe-set-type
    } macro
    '_ type '_to-quote ___quote___quote_++ ___quote___quote_++ {
      '__quote unsafe-set-type
    } macro
  } if
} macro

'#idx '#float8 unit '#latin1-char '#float8 unit

'_#idx_#idx_> {
  '#float8 1 #idx unsafe-set-type-at
  '#float8 0 #idx unsafe-set-type-at
  _#float8_#float8_>
  '#bc 0 #idx unsafe-set-type-at
} macro

'_#idx_#idx_>= {
  '#float8 1 #idx unsafe-set-type-at
  '#float8 0 #idx unsafe-set-type-at
  _#float8_#float8_>=
  '#bc 0 #idx unsafe-set-type-at
} macro

'_#idx_#idx_- {
  '#float8 1 #idx unsafe-set-type-at
  '#float8 0 #idx unsafe-set-type-at
  _#float8_#float8_-
  '#idx 0 #idx unsafe-set-type-at
} macro

'poly {
  !i !f
  f { '_ }
    { i 0 #idx _#idx_#idx_> }
    { i block-push
      'type-at symbol block-push
      '___quote___quote_++ symbol block-push
      '_ block-push
      '___quote___quote_++ symbol block-push
      i 1 #idx _#idx_#idx_- :i
    } while
    f block-push
    '___quote___quote_++ symbol block-push
    'eval symbol block-push
  macro
} macro

'+ 2 #idx poly '- 2 #idx poly '* 2 #idx poly '/ 2 #idx poly
'= 2 #idx poly '/= 2 #idx poly
'< 2 #idx poly '<= 2 #idx poly '> 2 #idx poly '>= 2 #idx poly
'and 2 #idx poly 'or 2 #idx poly 'not 1 #idx poly
'++ 2 #idx poly
'repr-of 1 #idx poly 'to-quote 1 #idx poly
'at 2 #idx poly 'len 1 #idx poly

'derive {
  !f 1 #idx - !i !res
  "" !name {} !body
  { i 0 #idx >= }
  { i lift !cur
    name '_ cur ++ ++ :name
    body
      cur '->repr ++ symbol block-push
      i block-push
      'unsafe-set-type-at symbol block-push
    :body
    i 1 #idx - :i
  } while
  name '_ f ++ ++
  body
    f symbol block-push
    res block-push
    0 #idx block-push
    'unsafe-set-type-at symbol block-push
  macro
} macro

'derive+ { 2 #idx '+ derive } macro
'derive- { 2 #idx '- derive } macro
'derive* { 2 #idx '* derive } macro
'derive/ { 2 #idx '/ derive } macro
'derive= { 2 #idx '= derive } macro
'derive/= { 2 #idx '/= derive } macro
'derive< { 2 #idx '< derive } macro
'derive<= { 2 #idx '<= derive } macro
'derive> { 2 #idx '> derive } macro
'derive>= { 2 #idx '>= derive } macro
'derive-and { 2 #idx 'and derive } macro
'derive-or { 2 #idx 'or derive } macro
'derive-not { 1 #idx 'not derive } macro
'derive++ { 2 #idx '++ derive } macro

[ A simply-numeric type is one that has identity multiplication and division.
  This could also be thought of as "algebraic" numeric types: it's for the case
  that traversing an array 10 times with a stride of 10 puts you at element 100.
]
'derive-simply-numeric {
  !bc !ty
  ty ty ty derive+ ty ty ty derive-
  ty ty ty derive* ty ty ty derive/
  ty ty bc derive= ty ty bc derive/=
  ty ty bc derive< ty ty bc derive<=
  ty ty bc derive> ty ty bc derive>=
} macro

[ Note, we have to derive #idx specially because it has custom-written
  derivations, which were necessary to support writing the derive macro itself.
]
'#idx '#idx '#idx derive+
'#idx '#idx '#idx derive* '#idx '#idx '#idx derive/
'#idx '#idx '#bc derive= '#idx '#idx '#bc derive/=
'#idx '#idx '#bc derive< '#idx '#idx '#bc derive<=

'#latin1-char '#bc derive-simply-numeric

'swap { 1 #idx lift } macro
'type-of { 0 #idx type-at swap drop } macro

'inc { !val val 1 val type-of eval + } macro
'dec { !val val 1 val type-of eval - } macro

'for {
  !body !change !check !preamble
  preamble flatten
  check
  body change ++
  while
} inline

'#t { 1 #bc } macro
'#f { 0 #bc } macro
