'! { bind } prefix
'@ { commit } prefix
'~ { delete } prefix

'rebind {
  dup delete bind
} inline

'recommit {
  dup delete commit
} inline

': { rebind } prefix
'; { recommit } prefix

'dup { !x x x } macro
'drop { !x } macro
'raw-drop { !x 'x raw-delete } macro

'unit {
  !base !type
  type add-type
  type {}
    base symbol block-push
    type block-push
    'unsafe-set-type symbol block-push
  macro
  type '->base-type ___quote___quote_++ {}
    base block-push
  macro
  '_ type '_base-type-of ___quote___quote_++ ___quote___quote_++ { drop }
    base block-push
  macro
  '_ base '_commit ___quote___quote_++ ___quote___quote_++ !base-commit
  { base-commit defined? }
  { type '->repr ___quote___quote_++ {}
      base '->repr ++ eval block-push
    macro
    '_ type '_repr-of ___quote___quote_++ ___quote___quote_++ { drop }
      base '->repr ++ eval block-push
    macro
    type '->size ++ {}
      base '->size ++ eval block-push
    macro
    '_ type '_size-of ++ ++ { drop }
      base '->size ++ eval block-push
    macro
    '_ type '_commit ___quote___quote_++ ___quote___quote_++ {}
      base-commit symbol block-push
    macro
    '_ type '_declare ___quote___quote_++ ___quote___quote_++ {}
      '_ base '_declare ___quote___quote_++ ___quote___quote_++
        symbol block-push
    macro
    type '->quote ___quote___quote_++ {
      '__quote unsafe-set-type
    } macro
    '_ type '_to-quote ___quote___quote_++ ___quote___quote_++ {
      '__quote unsafe-set-type
    } macro
  } if
} macro

'default-#integral { '#float8 } macro
'default-#rational { '#float8 } macro

'#idx default-#integral unit '#latin1-char default-#integral unit
'#B default-#integral unit

'_#idx_#idx_> {
  '#float8 1 #idx unsafe-set-type-at
  '#float8 0 #idx unsafe-set-type-at
  _#float8_#float8_>
  '#bc 0 #idx unsafe-set-type-at
} macro

'_#idx_#idx_>= {
  '#float8 1 #idx unsafe-set-type-at
  '#float8 0 #idx unsafe-set-type-at
  _#float8_#float8_>=
  '#bc 0 #idx unsafe-set-type-at
} macro

'_#idx_#idx_- {
  '#float8 1 #idx unsafe-set-type-at
  '#float8 0 #idx unsafe-set-type-at
  _#float8_#float8_-
  '#idx 0 #idx unsafe-set-type-at
} macro

'poly {
  !i !f
  f { '_ }
    { i 0 #idx _#idx_#idx_> }
    { i block-push
      'type-at symbol block-push
      '___quote___quote_++ symbol block-push
      '_ block-push
      '___quote___quote_++ symbol block-push
      i 1 #idx _#idx_#idx_- :i
    } while
    f block-push
    '___quote___quote_++ symbol block-push
    'eval symbol block-push
  macro
} macro

'+ 2 #idx poly '- 2 #idx poly '* 2 #idx poly '/ 2 #idx poly
'= 2 #idx poly '/= 2 #idx poly
'< 2 #idx poly '<= 2 #idx poly '> 2 #idx poly '>= 2 #idx poly
'and 2 #idx poly 'or 2 #idx poly 'not 1 #idx poly
'++ 2 #idx poly
'repr-of 1 #idx poly 'base-type-of 1 #idx poly 'to-quote 1 #idx poly
'at 2 #idx poly 'len 1 #idx poly

'derive {
  !f 1 #idx - !i !res
  "" !name {} !body
  { i 0 #idx >= }
  { i lift !cur
    name '_ cur ++ ++ :name
    body
      cur '->base-type ++ symbol block-push
      i block-push
      'unsafe-set-type-at symbol block-push
    :body
    i 1 #idx - :i
  } while
  name '_ f ++ ++
  body
    f symbol block-push
    res block-push
    0 #idx block-push
    'unsafe-set-type-at symbol block-push
  macro
} macro

'derive+ { 2 #idx '+ derive } macro
'derive- { 2 #idx '- derive } macro
'derive* { 2 #idx '* derive } macro
'derive/ { 2 #idx '/ derive } macro
'derive= { 2 #idx '= derive } macro
'derive/= { 2 #idx '/= derive } macro
'derive< { 2 #idx '< derive } macro
'derive<= { 2 #idx '<= derive } macro
'derive> { 2 #idx '> derive } macro
'derive>= { 2 #idx '>= derive } macro
'derive-and { 2 #idx 'and derive } macro
'derive-or { 2 #idx 'or derive } macro
'derive-not { 1 #idx 'not derive } macro
'derive++ { 2 #idx '++ derive } macro

[ A simply-numeric type is one that has identity multiplication and division.
  This could also be thought of as "algebraic" numeric types: it's for the case
  that traversing an array 10 times with a stride of 10 puts you at element 100.
]
'derive-simply-numeric {
  !bc !ty
  ty ty ty derive+ ty ty ty derive-
  ty ty ty derive* ty ty ty derive/
  ty ty bc derive= ty ty bc derive/=
  ty ty bc derive< ty ty bc derive<=
  ty ty bc derive> ty ty bc derive>=
} macro

[ Other ordinary numeric types produce different units from multiplication and
  division. These could be thought of as "geometric" numeric types: for example,
  meters * meters = meters-square.
]
'derive-numeric {
  !bc !div !mul !ty
  ty ty ty derive+ ty ty ty derive-
  ty ty mul derive* ty ty div derive/
  ty ty bc derive= ty ty bc derive/=
  ty ty bc derive< ty ty bc derive<=
  ty ty bc derive> ty ty bc derive>=
} macro

[ Simple logical types pass types through logical operators.
]
'derive-logical {
  !ty
  ty ty ty derive-and ty ty ty derive-or ty ty derive-not
  ty ty ty derive= ty ty ty derive/=
} macro

[ We have to derive #idx specially because it has custom-written derivations,
  which were necessary to support writing the derive macro itself.
]
'#idx '#idx '#idx derive+
'#idx '#idx '#idx derive* '#idx '#idx '#idx derive/
'#idx '#idx '#bc derive= '#idx '#idx '#bc derive/=
'#idx '#idx '#bc derive< '#idx '#idx '#bc derive<=

'#latin1-char '#bc derive-simply-numeric
'#B '#bc derive-simply-numeric

'swap { 1 #idx lift } macro
'type-of { 0 #idx type-at swap drop } macro

'inc { !val val 1 val type-of eval + } macro
'dec { !val val 1 val type-of eval - } macro

'for {
  !body !change !check !preamble
  preamble flatten
  check
  body change ++
  while
} inline

'#true { 1 #bc } macro
'#false { 0 #bc } macro
